```bash
MySQL is flexible with SQL syntax to improve developer convenience.

VALUE is technically intended for a single row, but MySQL doesn't enforce it.

It treats VALUE the same as VALUES under the hood.

But:
VALUES is more standard and explicit, making your code more readable.

Some other SQL databases (e.g., PostgreSQL, SQL Server) do not allow VALUE for multiple inserts.

Portability: If you ever switch databases, VALUES will work everywhere — VALUE might break.
```

```bash
In MySQL, it is possible to insert a string value into an INT column because MySQL performs implicit type conversion. 
Here's why it happens:

Why is MySQL Allowing String in INT Column?
MySQL tries to implicitly convert string values to integers when inserting data into INT columns.

If the string starts with numbers, MySQL extracts the numeric part.

If the string does not start with numbers, it is converted to 0.

If you want to strictly enforce integers and prevent strings from being inserted:

Use STRICT Mode:

SET sql_mode = 'STRICT_ALL_TABLES';
```

```bash
Why Multiple NULLs Are Allowed in a UNIQUE Column?

UNIQUE constraint enforces that no two values should be the same.

But NULL represents "unknown" — it's not considered a value.

Since each NULL is treated as unique, you can insert it multiple times.

according to the SQL standard, NULL is not equal to anything, not even to another NULL
```

```bash
Where Clause and Group By Clause --> What should be the proper sequence??
Answer -> Where Clause and then Group By ??
```

```bash
DELETE FROM customers;
DELETE FROM customers WHERE country = 'USA';

Characteristics:
Can delete specific rows using WHERE
Fully logged (row-level logging)
Slower for large tables
Triggers DO fire
Can be rolled back
Does NOT reset auto-increment/identity (in most DBs)
```

```bash
TRUNCATE
TRUNCATE TABLE customers;
removes all rows only
Much faster
Minimal logging
Triggers usually DO NOT fire
Often cannot be rolled back (depends on DB)
Resets auto-increment / identity
Cannot use WHERE
```

```bash
You can only roll back a DELETE if the delete happened inside a transaction that hasn’t been committed yet. 
Once it’s committed, the database considers it final and rollback won’t work.

BEGIN;
DELETE FROM customers WHERE country = 'USA';
-- Check what happened
SELECT * FROM customers;
ROLLBACK;
After ROLLBACK, the deleted rows come back.



DELETE FROM customers;
COMMIT;

You CANNOT use ROLLBACK.
Now your recovery options depend on your database setup:
```

```bash
```

```bash
```

```bash
```